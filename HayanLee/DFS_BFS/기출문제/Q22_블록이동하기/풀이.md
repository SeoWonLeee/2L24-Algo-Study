# Q22. ë¸”ë¡ ì´ë™í•˜ê¸°

### ğŸ’¡ Info

|   ì •ë³´    |                                   ë‚´ìš©                                    |
|:-------:|:-----------------------------------------------------------------------:|
|   ë‚œì´ë„   |                                 ğŸŸ¢ğŸŸ¢ğŸŸ¢                                  |
|  í’€ì´ ì‹œê°„  |                                   50ë¶„                                   | 
|  ì‹œê°„ ì œí•œ  |                                   1ì´ˆ                                    |
| ë©”ëª¨ë¦¬ ì œí•œ  |                                  128MB                                  |
|   ê¸°ì¶œ    |                            2020 ì¹´ì¹´ì˜¤ ì‹­ì… ê³µì±„ 1ì°¨                            |
|    ë§í¬   | [programmers](https://programmers.co.kr/learn/courses/30/lessons/60063) |

<br>
<br>

### ğŸ’­ ë¬¸ì œ ì´í•´
- 
<br>


> #### ì…ì¶œë ¥ ì˜ˆì‹œ
<img width="587" alt="image" src="https://github.com/hayannn/2L24-Algo-Study/assets/102213509/66af2e9b-a405-4996-a385-25b644d9e926">

<br>
<br>

### ğŸ’­ ìƒê°í•œ ì•Œê³ ë¦¬ì¦˜
```ì‹¤ì œ í’€ì´ ì‹œê°„ : 189ë¶„```

0. N ì…ë ¥
1. visited ìƒì„±í•˜ê¸°
2. dxì™€ dy ì´ˆê¸°í™”
3. BFS ì‹¤í–‰
    - Queueë¥¼ ìƒì„±í•˜ê³ , ì´ˆê¸° ìœ„ì¹˜(0, 0)ì™€ ë°©í–¥(0)ì„ ê°€ì§„ ë¡œë´‡ì„ offer
    - ì´ë•Œ, í•´ë‹¹ ìœ„ì¹˜ë¥¼ ë°©ë¬¸í–ˆìŒì„ í‘œì‹œí•˜ê¸° ìœ„í•´ visited ì²´í¬
    - while(true)
        - Queueì—ì„œ ë¡œë´‡ì„ pollí•˜ì—¬ í˜„ì¬ ìœ„ì¹˜ì™€ ë°©í–¥ ê°€ì ¸ì˜¤ê¸°
            - ë§Œì•½ í˜„ì¬ ë¡œë´‡ì´ ëª©ì ì§€ì— ë„ë‹¬í•œ ê²½ìš° -> ì‹œê°„ ë¦¬í„´
            - ë§Œì•½ ëª©ì ì§€ì— ë„ë‹¬í•˜ì§€ ëª»í•œ ê²½ìš° : -1

```java
    //ì•Œê³ ë¦¬ì¦˜ ì¶œì²˜ : https://thdbs523.tistory.com/263
    
    import java.util.*;
    
    class Solution {
    
        public int solution(int[][] board) {
            int N = board.length;
            boolean[][][] visited = new boolean[2][N][N];
            int[] dx = {-1, 1, 0, 0};
            int[] dy = {0, 0, -1, 1};
    
            Queue<Robot> queue = new LinkedList<>();
            queue.offer(new Robot(0, 0, 0, 0));
            visited[0][0][0] = true;
    
            while (!queue.isEmpty()) {
                Robot current = queue.poll();
                if ((current.d == 0 && current.x == N - 1 && current.y + 1 == N - 1) ||
                        (current.d == 1 && current.x + 1 == N - 1 && current.y == N - 1)) {
                    return current.time;
                }
    
                for (int i = 0; i < 4; i++) {
                    int nx = current.x + dx[i], ny = current.y + dy[i];
                    if (!isMoved(nx, ny, current.d, visited, board, N)){
                        continue;
                    }
                    visited[current.d][nx][ny] = true;
                    queue.offer(new Robot(nx, ny, current.d, current.time + 1));
                }
    
                for (int i = 0; i < 2; i++) {
                    int nextDir = (current.d + 1) % 2;
                    int nx = current.x + dx[i], ny = current.y + dy[i];
                    if (!isMoved(nx, ny, nextDir, visited, board, N)) continue;
                    visited[nextDir][nx][ny] = true;
                    queue.offer(new Robot(nx, ny, nextDir, current.time + 1));
                }
            }
            return -1;
        }
    
        static boolean isMoved(int x, int y, int d, boolean[][][] visited, int[][] board, int N) {
            if (x < 0 || x >= N || y < 0 || y >= N || visited[d][x][y] || board[x][y] == 1){
                return false;
            }
    
            if (d == 0 && (y + 1 >= N || board[x][y + 1] == 1)){
                return false;
            }
    
            if (d == 1 && (x + 1 >= N || board[x + 1][y] == 1)){
                return false;
            }
    
            return true;
        }
    
        static class Robot {
            int x, y, d, time;
            Robot(int x, int y, int d, int time) {
                this.x = x; this.y = y; this.d = d; this.time = time;
            }
        }
    }

  ```

<br>
<br>

### âŒ ì˜¤ë‹µì²´í¬
<img width="1180" alt="image" src="https://github.com/hayannn/2L24-Algo-Study/assets/102213509/b5583ca9-fbaf-43d1-821d-8ddb7e5d5c2d">

#### ğŸš€ ê¸°ëŒ“ê°’ì´ ì•„ë‹Œ 9ê°€ ì¶œë ¥ëœ ì´ìœ ?

#### ë¡œë´‡ì€ ë³´ë“œì˜ ì¢Œìƒë‹¨ (0, 0) ìœ„ì¹˜ì—ì„œ ì‹œì‘í•˜ëŠ”ë°, êµ¬í˜„í•œ ì•Œê³ ë¦¬ì¦˜ ì¤‘ ë¡œë´‡ì˜ íšŒì „ì— ëŒ€í•œ ì²˜ë¦¬ê°€ ì˜ëª»ë˜ì–´ ë¬¸ì œê°€ ë°œìƒí•œ ê²ƒìœ¼ë¡œ ë³´ì„.
- íšŒì „í•  ë•Œ ë¡œë´‡ì˜ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ íšŒì „ ê°€ëŠ¥ ì—¬ë¶€ë¥¼ íŒë‹¨í•´ì•¼ í•˜ëŠ”ë° â¡ï¸ ë‹¨ìˆœíˆ ì¢Œí‘œ ì´ë™ë§Œìœ¼ë¡œ íšŒì „ì„ ì²˜ë¦¬í•¨.
    - íšŒì „ ì¤‘ì‹¬ì´ ì˜ëª»ë˜ì—ˆìŒ.
        - ```ê°€ë¡œ ë°©í–¥ì—ì„œëŠ” (x, y)ì™€ (x, y+1) ìœ„ì¹˜ë¥¼ íšŒì „ ì¤‘ì‹¬ìœ¼ë¡œ í™•ì¸í•´ì•¼ í•˜ê³ , ì„¸ë¡œ ë°©í–¥ì—ì„œëŠ” (x, y)ì™€ (x+1, y) ìœ„ì¹˜ë¥¼ íšŒì „ ì¤‘ì‹¬ìœ¼ë¡œ í™•ì¸í•´ì•¼ í•¨!```

- ì‹œê°„ì„ ë°˜í™˜í•  ë•Œ ë„ì°© ì§€ì ì— ë„ì°©í–ˆì„ ë•Œì˜ ì‹œê°„ì„ ë°˜í™˜í•˜ê³  ìˆìŒ.
    - ```ë¡œëª»ì´ ë„ì°© ì§€ì ì— ë„ì°©í–ˆì„ ë•Œ ì‹œê°„ì„ í•˜ë‚˜ ë” ì¦ê°€ì‹œì¼œì•¼ í•¨!```

<br>

#### ğŸš€ ì˜ëª»ëœ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë‚˜ì˜¤ê²Œ ë˜ëŠ” ê²°ê³¼ëŠ”?
> ì…ë ¥

```
[[0, 0, 0, 1, 1],
[0, 0, 0, 1, 0],
[0, 1, 0, 1, 1],
[1, 1, 0, 0, 1],
[0, 0, 0, 0, 0]]
```

> ìµœë‹¨ ê±°ë¦¬
```
(0, 0) -> (0, 1) (ì‹œì‘)
(0, 1) -> (0, 2) (ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™)
(0, 2) -> (0, 3) (ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™)
(0, 3) -> (1, 3) (ì•„ë˜ë¡œ ì´ë™)
(1, 3) -> (2, 3) (ì•„ë˜ë¡œ ì´ë™)   
(2, 3) -> (3, 3) (ì•„ë˜ë¡œ ì´ë™)
(3, 3) -> (3, 4) (ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™)
(3, 4) -> (4, 4) (ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™, ë„ì°©)
```
â¡ï¸ ë¡œë´‡ì´ (4, 4) ìœ„ì¹˜ë¡œ ì´ë™í•˜ëŠ” ìµœì†Œ ì‹œê°„ì€ 8ì‹œê°„ì´ ë˜ì–´ë²„ë¦¼.
â¡ï¸ ë˜, ì½”ë“œì—ì„œëŠ” ë¡œë´‡ì´ ë„ì°©ì§€ì— ë„ë‹¬í•˜ë©´ ì‹œê°„ì„ í•˜ë‚˜ ì¦ê°€ì‹œì¼œì„œ ë°˜í™˜í•˜ë¯€ë¡œ, ì‹¤ì œ ì¶œë ¥ ê°’ì€ 9ê°€ ë˜ì–´ë²„ë¦¼.

<br>

#### ğŸš€ ì½”ë“œë¥¼ ìˆ˜ì •í•´ì•¼ í•˜ëŠ” ë¶€ë¶„(chatGPTì˜ ë„ì›€ì„ ë°›ìŒ.)
1. í´ë˜ìŠ¤ ë‚´ë¶€ì˜ í•„ë“œ ë° ë©”ì†Œë“œ ì •ì˜
    - í˜„ì¬ ì½”ë“œ : Robot í´ë˜ìŠ¤ë¥¼ ë‚´ë¶€ì— ì •ì˜í•˜ê³  ì‚¬ìš©
    - ìˆ˜ì •í•  ì½”ë“œ : Robot í´ë˜ìŠ¤ ëŒ€ì‹ ì— int[] ë°°ì—´ì„ í™œìš©í•˜ì—¬ ë¡œë´‡ì˜ ìœ„ì¹˜ì™€ ë°©í–¥ì„ í‘œí˜„

<br>

2. ë°©í–¥ í‘œì‹œ ë°©ë²• ë³€ê²½
    - í˜„ì¬ ì½”ë“œ : Robot ê°ì²´ì˜ d í•„ë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë°©í–¥ì„ ë‚˜íƒ€ëƒ„.
    - ìˆ˜ì •í•  ì½”ë“œ : ë°©í–¥ì„ ë°°ì—´ì˜ ì¸ë±ìŠ¤ë¡œ ëŒ€ì²´í•˜ì—¬ ë°©í–¥ì„ í‘œí˜„

<br>

3. ì´ë™ ë° íšŒì „ ì¡°ê±´ í™•ì¸ ë°©ë²• ë³€ê²½
    - í˜„ì¬ ì½”ë“œ : ë¡œë´‡ ê°ì²´ì˜ ë°©í–¥ì— ë”°ë¼ ì´ë™ ë° íšŒì „ ì¡°ê±´ì„ í™•ì¸
    - ìˆ˜ì •í•  ì½”ë“œ : ë°°ì—´ì˜ ì¸ë±ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë™ ë° íšŒì „ ì¡°ê±´ì„ í™•ì¸

<br>

4. ë³€ìˆ˜ ë° ë°°ì—´ ì •ì˜ ìœ„ì¹˜ ë³€ê²½
    - ìˆ˜ì •í•  ì½”ë“œ : ë³€ìˆ˜ ë° ë°°ì—´ì„ ë°˜ë³µë¬¸ ë‚´ì—ì„œ ì •ì˜í•˜ëŠ” ëŒ€ì‹  í´ë˜ìŠ¤ì˜ ë©¤ë²„ë¡œ ì •ì˜í•˜ì—¬ ì¬ì‚¬ìš©

<br>
<br>

### ğŸ’­ ìµœì¢… í’€ì´
0. N ì…ë ¥
1. visited ìƒì„±í•˜ê¸° : N x N í¬ê¸°ì˜ 3ì°¨ì› boolean ë°°ì—´ë¡œ ë°©ë¬¸ ì—¬ë¶€ ì¶”ì 
    - ë¡œë´‡ì˜ ë°©í–¥(d), xì¢Œí‘œ, yì¢Œí‘œë¥¼ ì¸ë±ìŠ¤ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
2. dxì™€ dy ì´ˆê¸°í™”
3. BFS ì‹¤í–‰
    - Queueë¥¼ ìƒì„±í•˜ê³ , ì´ˆê¸° ìœ„ì¹˜(0, 0)ì™€ ë°©í–¥(0)ì„ ê°€ì§„ ë¡œë´‡ì„ offer
    - ì´ë•Œ, í•´ë‹¹ ìœ„ì¹˜ë¥¼ ë°©ë¬¸í–ˆìŒì„ í‘œì‹œí•˜ê¸° ìœ„í•´ visited ì²´í¬
    - while(true) ë£¨í”„ ì‹œì‘
        - Queueì—ì„œ ë¡œë´‡ì„ pollí•˜ì—¬ í˜„ì¬ ìœ„ì¹˜ì™€ ë°©í–¥ ê°€ì ¸ì˜¤ê¸°
            - ë§Œì•½ í˜„ì¬ ë¡œë´‡ì´ ëª©ì ì§€ì— ë„ë‹¬í•œ ê²½ìš° -> ì‹œê°„ ë°˜í™˜
            - ë§Œì•½ ëª©ì ì§€ì— ë„ë‹¬í•˜ì§€ ëª»í•œ ê²½ìš° : -1 ë°˜í™˜
            - ë¡œë´‡ì˜ ì´ë™ê³¼ íšŒì „ ì²˜ë¦¬
                - ìƒí•˜ì¢Œìš° ì´ë™ ê°€ëŠ¥í•œì§€ í™•ì¸í•˜ê³ , ì´ë™ ê°€ëŠ¥í•œ ê²½ìš° Queueì— ì¶”ê°€í•˜ê³  í•´ë‹¹ ìœ„ì¹˜ë¥¼ ë°©ë¬¸í–ˆìŒì„ í‘œì‹œí•˜ê¸° ìœ„í•´ visited ì²´í¬
                - ê°€ë¡œ ë°©í–¥ì¼ ë•ŒëŠ” ì„¸ë¡œë¡œ íšŒì „ì´ ê°€ëŠ¥í•œì§€ í™•ì¸í•˜ê³  ê°€ëŠ¥í•œ ê²½ìš° Queueì— ì¶”ê°€í•˜ê³  í•´ë‹¹ ìœ„ì¹˜ë¥¼ ë°©ë¬¸í–ˆìŒì„ í‘œì‹œí•˜ê¸° ìœ„í•´ visited ì²´í¬
                - ì„¸ë¡œ ë°©í–¥ì¼ ë•ŒëŠ” ê°€ë¡œë¡œ íšŒì „ì´ ê°€ëŠ¥í•œì§€ í™•ì¸í•˜ê³  ê°€ëŠ¥í•œ ê²½ìš° Queueì— ì¶”ê°€í•˜ê³  í•´ë‹¹ ìœ„ì¹˜ë¥¼ ë°©ë¬¸í–ˆìŒì„ í‘œì‹œí•˜ê¸° ìœ„í•´ visited ì²´í¬
```java
package HayanLee.DFS_BFS.ê¸°ì¶œë¬¸ì œ.Q22_ë¸”ë¡ì´ë™í•˜ê¸°;

//ì•Œê³ ë¦¬ì¦˜ ì¶œì²˜ : https://thdbs523.tistory.com/263

import java.util.*;

class Solution {

    static int N;
    static int[][] board;
    static boolean[][][] visited;
    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};

    public int solution(int[][] board) {
        N = board.length;
        visited = new boolean[2][N][N];

        return bfs(board);
    }

    static int bfs(int[][] board) {
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0, 0, 0, 0});
        visited[0][0][0] = true;

        while (!queue.isEmpty()) {
            int[] current = queue.poll();
            int x = current[0];
            int y = current[1];
            int d = current[2];
            int time = current[3];

            if ((d == 0 && (x == N - 1 && y + 1 == N - 1 || x == N - 1 && y == N - 1)) || (d == 1 && (x + 1 == N - 1 && y == N - 1 || x == N - 1 && y == N - 1))) {
                return time;
            }

            // ìƒí•˜ì¢Œìš° ì´ë™
            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i];
                int ny = y + dy[i];

                if (isMoved(nx, ny, d, board)) {
                    visited[d][nx][ny] = true;
                    queue.offer(new int[]{nx, ny, d, time + 1});
                }
            }

            // ê°€ë¡œ ë°©í–¥ì¼ ë•Œ íšŒì „
            if (d == 0) {
                for (int i = 2; i < 4; i++) {
                    int nx = x + dx[i];
                    int ny = y + dy[i];

                    if (isMoved(nx, ny, 1, board)) {
                        visited[1][nx][ny] = true;
                        queue.offer(new int[]{nx, ny, 1, time + 1});
                    }
                }
            }

            // ì„¸ë¡œ ë°©í–¥ì¼ ë•Œ íšŒì „
            if (d == 1) {
                for (int i = 0; i < 2; i++) {
                    int nx = x + dx[i];
                    int ny = y + dy[i];

                    if (isMoved(nx, ny, 0, board)) {
                        visited[0][nx][ny] = true;
                        queue.offer(new int[]{nx, ny, 0, time + 1});
                    }
                }
            }
        }
        return -1;
    }

    static boolean isMoved(int x, int y, int d, int[][] board) {
        if (x < 0 || x >= N || y < 0 || y >= N || visited[d][x][y] || board[x][y] == 1)
            return false;

        if (d == 0 && (y + 1 >= N || board[x][y + 1] == 1)) {
            return false;
        }

        if (d == 1 && (x + 1 >= N || board[x + 1][y] == 1)) {
            return false;
        }

        return true;
    }
}
```
<br>

#### ê·¸ëŸ¼ì—ë„ í…ŒìŠ¤íŠ¸ëŠ” í†µê³¼ë˜ì§€ë§Œ ì±„ì ì—ì„œëŠ” íˆë“  ì¼€ì´ìŠ¤ ì‹¤íŒ¨ë¡œ í‹€ë¦¬ëŠ” ë¬¸ì œ ë°œìƒ -> ì•Œê³ ë¦¬ì¦˜ ë ˆí¼ëŸ°ìŠ¤ë¡œ í•´ê²°
```java
package HayanLee.DFS_BFS.ê¸°ì¶œë¬¸ì œ.Q22_ë¸”ë¡ì´ë™í•˜ê¸°;

//ì•Œê³ ë¦¬ì¦˜ ì¶œì²˜ : https://thdbs523.tistory.com/263

import java.util.*;

class Solution {

    static int[][] nowBoard;
    static int result= 0;
    static boolean[][][] visited;
    static int N;

    // ìƒí•˜ì¢Œìš° ì´ë™
    static int[][] move = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    // ê°€ë¡œ -> ì„¸ë¡œ íšŒì „ (â†– â†™ â†— â†˜ ìˆœì„œ)
    static int[][] hTurn = {{-1, 0}, {0, 0}, {-1, 1}, {0, 1}};

    //ë²½ í™•ì¸
    static int[][] hBlock = {{-1, 1}, {1, 1}, {-1, 0}, {1, 0}};

    // ì„¸ë¡œ -> ê°€ë¡œ íšŒì „ (â†– â†™ â†— â†˜ ìˆœì„œ)
    static int[][] wTurn = {{0, -1}, {1, -1}, {0, 0}, {1, 0}};

    //ë²½ í™•ì¸
    static int[][] wBlock = {{1, -1}, {0, -1}, {1, 1}, {0, 1}};

    public int solution(int[][] board) {
        nowBoard = board;
        N = board.length;

        // ê°€ë¡œ = 0, ì„¸ë¡œ = 1
        visited = new boolean[2][N][N];

        bfs();
        return result;
    }

    static void bfs() {
        Queue<Robot> queue = new LinkedList<>();

        queue.offer(new Robot(0, 0, 0, 0));
        visited[0][0][0] = true;

        while(!queue.isEmpty()) {
            Robot now = queue.poll();

            if((now.d == 0 && now.x == N - 1 && now.y + 1 == N - 1) || (now.d == 1 && now.x + 1 == N - 1 && now.y == N - 1)) {
                result = now.time;
                break;
            }

            // ìƒí•˜ì¢Œìš°ë¡œ í™•ì¸
            for(int i=0;i<4;i++) {
                int nX = now.x + move[i][0];
                int nY = now.y + move[i][1];

                if(check(nX, nY, now.d)) {
                    visited[now.d][nX][nY] = true;
                    queue.offer(new Robot(nX, nY, now.d, now.time + 1));
                }
            }

            //1. ê°€ë¡œ -> ì„¸ë¡œë¡œ íšŒì „
            if(now.d == 0) {
                for(int i=0;i<4;i++) {
                    int nX = now.x + hTurn[i][0];
                    int nY = now.y + hTurn[i][1];
                    int nD = 1;

                    if(check(nX, nY, nD) && nowBoard[now.x + hBlock[i][0]][now.y + hBlock[i][1]] == 0) {
                        visited[nD][nX][nY] = true;
                        queue.offer(new Robot(nX, nY, nD, now.time + 1));
                    }
                }
            }

            //2. ì„¸ë¡œ -> ê°€ë¡œë¡œ íšŒì „
            else {
                for(int i=0;i<4;i++) {
                    int nX = now.x + wTurn[i][0];
                    int nY = now.y + wTurn[i][1];
                    int nD = 0;

                    if(check(nX, nY, nD) && nowBoard[now.x + wBlock[i][0]][now.y + wBlock[i][1]] == 0) {
                        visited[nD][nX][nY] = true;
                        queue.offer(new Robot(nX, nY, nD, now.time + 1));
                    }
                }
            }
        }
    }

    static boolean check(int x, int y, int d) {

        // ë²”ìœ„ ë°–
        if(x<0 || y<0 || x>=N || y>=N || visited[d][x][y] || nowBoard[x][y] == 1){
            return false;
        }

        if(d == 0 && (y+1 >= N || nowBoard[x][y + 1] == 1)) {
            return false;
        }

        if(d == 1 && (x + 1 >= N || nowBoard[x + 1][y] == 1)) {
            return false;
        }

        return true;
    }

    static class Robot {
        int x, y, d, time;

        Robot(int x, int y, int d, int time) {
            this.x = x;
            this.y = y;
            this.d = d;
            this.time = time;
        }
    }
}

```
<img width="493" alt="image" src="https://github.com/hayannn/2L24-Algo-Study/assets/102213509/aafb516f-39b5-4d4f-983e-727d7096bc4c">

# Q1. 모험가 길드

### 💡 Info

|   정보    |    내용     |
|:-------:|:---------:|
|   난이도   |   🟢⚪⚪    |
|  풀이 시간  |    30분    | 
|  시간 제한  |    1초     |
| 메모리 제한  |   128MB   |
|   기출    |   핵심유형    |
| 강의 | [(이코테 2021 강의 몰아보기) 2. 그리디 & 구현](https://youtu.be/2zjoKjt97vQ?si=wJmKseak5ODO0G89&t=1412) |

<br>
<br>

### 💭 문제 이해
- 모험가 N명
- '공포도'가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해 여행을 떠날 수 있음.
- 여행을 떠날 수 있는 그룹 수의 최댓값을 구하는 프로그램 작성
- 그룹 조건
  - 몇 명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을 필요는 없음.

<br>

> #### 입력 조건
>  - 첫째 줄에 모험가의 수 N이 주어집니다.(1<= N <=100,000)
>  - 둘째 줄에 각 모험가의 공포도의 값을 N 이하의 자연수로 주어지며, 각 자연수는 공백으로 구분합니다.
>      ```
>      5
>      2 3 1 2 2
>      ```

> #### 출력 조건
>  - 여행을 떠날 수 있는 그룹 수의 최댓값을 출력합니다.
>       ```
>       2
>       ```

<br>
<br>

### 💭 생각한 알고리즘
```실제 풀이 시간 : 46분(초과)```

- 모험가 N과 각 공포도 입력받기
- 입력받은 공포도 배열 정렬하기
- 그룹의 개수를 나타내는 result, 그 그룹 안의 모험가 수를 나타내는 count 정의하기
- 만약, 현재 그룹에 포함된 모험가의 수 >= 현재의 공포도 이상이라면, 그룹만들기
  ```java
  for(int i=0; i<N; i++){
      count += 1;
      if(count >= arr[i]){ // 현재 그룹 안 모험가수 >= 현재의 공포도 라면
          result += 1; //그룹만들기
      }
  }
  ```

<br>
<br>

### ❌ 오답체크
- 그룹 만들기가 진행되고 나면 -> 모험가 수는 초기화 하기!
- 모험가 수를 초기화하지 않으면 모험가수가 매번 증가해서, 현재의 구분 방식에 무조건 부합해져 1명이 한 그룹에 들어가는 상황이 발생됨.
    ```java
    for(int i=0; i<N; i++){
        count += 1;
        if(count >= arr[i]){
            result += 1;
            count = 0; //틀린 이유 -> 초기화를 진행하지 않아 '5'가 나옴
        }
    }
    ```

<br>
<br>

### 💭 최종 풀이
- 모험가 N과 각 공포도 입력받기
- 입력받은 공포도 배열 정렬하기
- 그룹의 개수를 나타내는 result, 그 그룹 안의 모험가 수를 나타내는 count 정의하기
- 만약, 현재 그룹에 포함된 모험가의 수 >= 현재의 공포도 이상이라면, 그룹만들기
  - 그룹 만들기가 진행되고 나면 -> 모험가 수는 초기화 하기!
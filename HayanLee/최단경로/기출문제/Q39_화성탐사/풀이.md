# í™”ì„± íƒì‚¬

|   ì •ë³´    |    ë‚´ìš©    |
|:-----------:|:--------:|
|   ë‚œì´ë„   |  ğŸŸ¢ğŸŸ¢âšª   |
|  í’€ì´ ì‹œê°„  |   40ë¶„    |
|  ì‹œê°„ ì œí•œ  |    1ì´ˆ    |
| ë©”ëª¨ë¦¬ ì œí•œ  |  128MB   |
| ê¸°ì¶œ | ACM-ICPC |

<br>
<br>

### â–«ï¸ ë¬¸ì œ ì •ë³´
- ë‹¹ì‹ ì€ í™”ì„± íƒì‚¬ ê¸°ê³„ë¥¼ ê°œë°œí•˜ëŠ” í”„ë¡œê·¸ë˜ë¨¸ì…ë‹ˆë‹¤.
- ê·¸ëŸ°ë° í™”ì„±ì€ ì—ë„ˆì§€ ê³µê¸‰ì›ì„ ì°¾ê¸°ê°€ í˜ë“­ë‹ˆë‹¤.
- ê·¸ë˜ì„œ ì—ë„ˆì§€ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•˜ê³ ì í™”ì„± íƒì‚¬ ê¸°ê³„ê°€ ì¶œë°œ ì§€ì ì—ì„œ ëª©í‘œ ì§€ì ê¹Œì§€ ì´ë™í•  ë•Œ í•­ìƒ ìµœì ì˜ ê²½ë¡œë¥¼ ì°¾ë„ë¡ ê°œë°œí•´ì•¼ í•©ë‹ˆë‹¤.
- í™”ì„± íƒì‚¬ ê¸°ê³„ê°€ ì¡´ì¬í•˜ëŠ” ê³µê°„ì€ N x N í¬ê¸°ì˜ 2ì°¨ì› ê³µê°„ì´ë©°, ê°ê°ì˜ ì¹¸ì„ ì§€ë‚˜ê¸° ìœ„í•œ ë¹„ìš©(ì—ë„ˆì§€ ì†Œëª¨ëŸ‰)ì´ ì¡´ì¬í•©ë‹ˆë‹¤.
- ê°€ì¥ ì™¼ìª½ ìœ„ ì¹¸ì¸ [0][0] ìœ„ì¹˜ì—ì„œ ê°€ì¥ ì˜¤ë¥¸ìª½ ì•„ë˜ ì¹¸ì¸ [N - 1][N - 1] ìœ„ì¹˜ë¡œ ì´ë™í•˜ëŠ” ìµœì†Œ ë¹„ìš©ì„ ì¶œë ¥í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì„¸ìš”.
- í™”ì„± íƒì‚¬ ê¸°ê³„ëŠ” íŠ¹ì •í•œ ìœ„ì¹˜ì—ì„œ ìƒí•˜ì¢Œìš° ì¸ì ‘í•œ ê³³ìœ¼ë¡œ 1ì¹¸ì”© ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<br>
<br>

### â–«ï¸ ì…ì¶œë ¥ ì¡°ê±´
- ì…ë ¥
  - ì²«ì§¸ ì¤„ì— í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ìˆ˜ T(1 <= T <= 10)ê°€ ì£¼ì–´ì§‘ë‹ˆë‹¤.
  - ë§¤ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ì²«ì§¸ ì¤„ì—ëŠ” íƒì‚¬ ê³µê°„ì˜ í¬ê¸°ë¥¼ ì˜ë¯¸í•˜ëŠ” ì •ìˆ˜ Nì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. (2 <= N <= 125)
  - ì´ì–´ì„œ Nê°œì˜ ì¤„ì— ê±¸ì³ ê° ì¹¸ì˜ ë¹„ìš©ì´ ì£¼ì–´ì§€ë©° ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•©ë‹ˆë‹¤. (0 <= ê° ì¹¸ì˜ ë¹„ìš© <= 9)
  

- ì¶œë ¥
  - ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë§ˆë‹¤ [0][0]ì˜ ìœ„ì¹˜ì—ì„œ [N - 1][N - 1]ì˜ ìœ„ì¹˜ë¡œ ì´ë™í•˜ëŠ” ìµœì†Œ ë¹„ìš©ì„ í•œ ì¤„ì— í•˜ë‚˜ì”© ì¶œë ¥í•©ë‹ˆë‹¤.

<br>
<br>

### â–«ï¸ ì…ì¶œë ¥ ì˜ˆì‹œ
```java
//ì…ë ¥
3
3
5 5 4
3 9 1
3 2 7
5
3 7 2 0 1
2 8 0 9 1
1 2 1 8 1
9 8 9 2 0
3 6 5 1 5
7
9 0 5 1 1 5 3
4 1 2 1 6 5 3
0 7 6 1 6 8 5
1 1 7 8 3 2 3
9 4 0 7 6 4 1
5 8 3 2 4 8 3
7 4 8 4 8 3 4
```
```java
//ì¶œë ¥
20
19
36
```

<br>
<br>

### â–«ï¸ ì•Œê³ ë¦¬ì¦˜
- ```í’€ì´ ì‹œê°„ : 47ë¶„(ì´ˆê³¼)```

1. í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ìˆ˜ T, N, ë°°ì—´ ì…ë ¥ë°›ê¸°
2. ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„í•˜ê¸°
    - Node í´ë˜ìŠ¤ë¥¼ Comparableë¡œ ì§€ì •í•´ì„œ ë§Œë“¤ê¸°
    - ìµœë‹¨ ê±°ë¦¬ì— ëŒ€í•œ ë…¸ë“œ ì •ë³´ ì¶œë ¥í•˜ê¸°
    - ë§µì˜ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš°ë¥¼ ì œê±°í•´ì•¼ í•¨.

```java
//ì²« í’€ì´ ì†ŒìŠ¤ì½”ë“œ
package HayanLee.ìµœë‹¨ê²½ë¡œ.ê¸°ì¶œë¬¸ì œ.Q39_í™”ì„±íƒì‚¬;

import java.util.*;

class Node implements Comparable<Node> {

    private int x;
    private int y;
    private int distance;

    public Node(int x, int y, int distance) {
        this.x = x;
        this.y = y;
        this.distance = distance;
    }

    public int getX() {
        return this.x;
    }

    public int getY() {
        return this.y;
    }

    public int getDistance() {
        return this.distance;
    }
    @Override
    public int compareTo(Node other) {
        if (this.distance < other.distance) {
            return -1;
        }
        return 1;
    }
}

public class MarsExploration {

    //ìƒí•˜ì¢Œìš° ì´ˆê¸°ê°’ ì„¤ì •
    static int[] dx = {-1, 0, 1, 0};
    static int[] dy = {0, 1, 0, -1};
    static final int INF = (int) 1e9;
    static int[][] TD;
    static int[][] SD;
    static int T;
    static int N;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        T = sc.nextInt();
        for (int i = 0; i < T; i++) {
            N = sc.nextInt();

            TD = new int [125][125];

            for (int j = 0; j < N; j++) {
                for (int k = 0; k < N; k++) {
                    TD[j][k] = sc.nextInt();
                }
            }

            SD = new int [125][125];

            for (int j = 0; j < N; j++) {
                Arrays.fill(SD[j], INF);
            }

            int x = 0;
            int y = 0;

            //ìš°ì„ ìˆœìœ„ íë¡œ êµ¬í˜„
            PriorityQueue<Node> pq = new PriorityQueue<>();
            pq.offer(new Node(0, 0, TD[x][y]));
            SD[x][y] = TD[x][y];

            while(!pq.isEmpty()) {
                Node node = pq.poll();
                int distance = node.getDistance();
                x = node.getX();
                y = node.getY();
                if (TD[x][y] < distance) {
                    continue;
                }

                for (int j = 0; j < 4; j++) {
                    int nx = x + dx[j];
                    int ny = y + dy[j];
                    int cost = distance + TD[nx][ny];

                    if (cost < SD[nx][ny]) {
                        SD[nx][ny] = cost;
                        pq.offer(new Node(nx, ny, cost));
                    }
                    //ë§µ ë²”ìœ„ ë°”ê¹¥
                    if (nx < 0 || nx >= N || ny < 0 || ny >= N) {
                        continue;
                    }


                }
            }
            int result = SD[N-1][N-1];
            System.out.println(result);
        }
    }
}

```

<br>
<br>

### ğŸš€ Trouble-Shooting

1. ```Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 125```
    - ë§µ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ë¶€ë¶„ì„ ë¨¼ì € ì‘ì„±í•´ì•¼ í–ˆëŠ”ë°, ê·¸ë ‡ì§€ ì•Šì•„ ìƒê¸´ ë¬¸ì œ

```java
//before
for (int j = 0; j < 4; j++) {
    int nx = x + dx[j];
    int ny = y + dy[j];
    int cost = distance + TD[nx][ny];
    
    if (cost < SD[nx][ny]) {
        SD[nx][ny] = cost;
        pq.offer(new Node(nx, ny, cost));
    }
    //ë§µ ë²”ìœ„ ë°”ê¹¥
    if (nx < 0 || nx >= N || ny < 0 || ny >= N) {
        continue;
    }

    
        
    
//after
for (int j = 0; j < 4; j++) {
    int nx = x + dx[j];
    int ny = y + dy[j];
    //ë§µ ë²”ìœ„ ë°”ê¹¥
    if (nx < 0 || nx >= N || ny < 0 || ny >= N) {
        continue;
    }

    int cost = distance + TD[nx][ny];
    if (cost < SD[nx][ny]) {
        SD[nx][ny] = cost;
        pq.offer(new Node(nx, ny, cost));
    }
}
```
<br>

2. ê²°ê³¼ê°’ì´ 1000000000ìœ¼ë¡œ ë‚˜ì˜¤ëŠ” ë¬¸ì œ
   - ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ ë‚´ë¶€ì˜ ì´ë¯¸ ì²˜ë¦¬ëœ ë…¸ë“œ ë¶€ë¶„ì„ TDë¡œ ì˜ëª» ì‘ì„±í•´ ìƒê¸´ ë¬¸ì œ â¡ï¸ SDë¡œ ë°”ê¿”ì•¼ í•¨!

```java
//before
while(!pq.isEmpty()) {
    Node node = pq.poll();
    int dist = node.getDistance();
    x = node.getX();
    y = node.getY();
    if (TD[x][y] < dist) {
        continue;
    }


//after
while(!pq.isEmpty()) {
    Node node = pq.poll();
    int dist = node.getDistance();
    x = node.getX();
    y = node.getY();
    if (SD[x][y] < dist) {
        continue;
    }
```

<br>
<br>

### â–«ï¸ ìµœì¢… í’€ì´
- MarsExploration2.java ì°¸ê³ 

![image](https://github.com/hayannn/2L24-Algo-Study/assets/102213509/f98c9dba-d652-4d6d-869c-aeb51c67f549)

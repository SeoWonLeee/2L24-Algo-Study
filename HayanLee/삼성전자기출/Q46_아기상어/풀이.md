# ì•„ê¸° ìƒì–´

|   ì •ë³´    |                ë‚´ìš©                 |
|:-----------:|:---------------------------------:|
|   ë‚œì´ë„   |               ğŸŸ¢ğŸŸ¢âšª               |
|  í’€ì´ ì‹œê°„  |                50ë¶„                |
|  ì‹œê°„ ì œí•œ  |                2ì´ˆ                 |
| ë©”ëª¨ë¦¬ ì œí•œ  |               512MB               |
| ê¸°ì¶œ |              ì‚¼ì„±ì „ì ê³µì±„              |
| ë§í¬ | https://acmicpc.net/problem/16236 |

<br>
<br>

### â–«ï¸ ë¬¸ì œ ì •ë³´
![image](https://github.com/hayannn/2L24-Algo-Study/assets/102213509/174239f8-2d5c-4852-b5fd-c8f4e836528b)

<br>
<br>

### â–«ï¸ ì…ì¶œë ¥ ì˜ˆì‹œ
```java
//ì…ë ¥1
3
0 0 0
0 0 0
0 9 0
```
```java
//ì¶œë ¥1
0
```

<br>

```java
//ì…ë ¥2
3
0 0 1
0 0 0
0 9 0
```
```java
//ì¶œë ¥2
3
```

<br>

```java
//ì…ë ¥3
4
4 3 2 1
0 0 0 0
0 0 9 0
1 2 3 4
```
```java
//ì¶œë ¥3
14
```

<br>

```java
//ì…ë ¥4
6
5 4 3 2 3 4
4 3 2 3 4 5
3 2 9 5 6 6
2 1 2 3 4 5
3 2 1 6 5 4
6 6 6 6 6 6
```
```java
//ì¶œë ¥4
60
```

<br>

```java
//ì…ë ¥5
6
6 0 6 0 6 1
0 0 0 0 0 2
2 3 4 5 6 6
0 0 0 0 0 2
0 2 0 0 0 0
3 9 3 0 0 1
```
```java
//ì¶œë ¥5
48
```

<br>

```java
//ì…ë ¥6
6
1 1 1 1 1 1
2 2 6 2 2 3
2 2 5 2 2 3
2 2 2 4 6 3
0 0 0 0 0 6
0 0 0 0 0 9
```
```java
//ì¶œë ¥6
39
```

<br>
<br>

### â–«ï¸ ì²« ë²ˆì§¸ ì•Œê³ ë¦¬ì¦˜
- ```í’€ì´ ì‹œê°„ : 17ë¶„```
1. N ì…ë ¥ë°›ê¸°
2. ë°°ì—´ ì…ë ¥ë°›ê¸°
3. BFS ì§„í–‰í•˜ê¸° ë° ì¶œë ¥
4. BFS(ë³„ë„ ë©”ì„œë“œë¡œ êµ¬í˜„)

```java
//ì²« í’€ì´ ì†ŒìŠ¤ì½”ë“œ
package HayanLee.ì‚¼ì„±ì „ìê¸°ì¶œ.Q46_ì•„ê¸°ìƒì–´;

import java.util.*;

class BabyShark_BFS {
   static int[][] map;
   static boolean[][] visited;
   static int[] dx = {-1, 1, 0, 0};
   static int[] dy = {0, 0, -1, 1};
   static int N;

   public static void main(String[] args) {
      Scanner scanner = new Scanner(System.in);
      N = scanner.nextInt();
      map = new int[N][N];
      visited = new boolean[N][N];

      // ë°°ì—´ ì…ë ¥ ë°›ê¸°
      for (int i = 0; i < N; i++) {
         for (int j = 0; j < N; j++) {
            map[i][j] = scanner.nextInt();
         }
      }

      // BFS ì§„í–‰ ë° ì¶œë ¥
      int result = bfs();
      System.out.println(result);
   }

   static int bfs() {
      Queue<int[]> queue = new LinkedList<>();
      int[] start = find();
      int sharkX = start[0];
      int sharkY = start[1];
      int sharkSize = 2; // ì•„ê¸° ìƒì–´ í¬ê¸°
      int eatCount = 0; // ë¨¹ì€ ë¬¼ê³ ê¸° ìˆ˜
      int moveCount = 0; // ì´ë™ íšŸìˆ˜

      while (true) {
         visited = new boolean[N][N];
         queue.clear();
         queue.add(new int[]{sharkX, sharkY, 0});
         visited[sharkX][sharkY] = true;
         boolean found = false;

         ArrayList<int[]> eatList = new ArrayList<>();

         while (!queue.isEmpty()) {
            int[] now = queue.poll();
            int x = now[0];
            int y = now[1];
            int dist = now[2];

            if (map[x][y] != 0 && map[x][y] < sharkSize) {
               eatList.add(new int[]{x, y, dist});
               found = true;
            }

            for (int i = 0; i < 4; i++) {
               int nx = x + dx[i];
               int ny = y + dy[i];

               if (nx >= 0 && nx < N && ny >= 0 && ny < N && !visited[nx][ny] && map[nx][ny] <= sharkSize) {
                  queue.add(new int[]{nx, ny, dist + 1});
                  visited[nx][ny] = true;
               }
            }
         }

         if (!found) {
            return moveCount;
         }

         Collections.sort(eatList, (a, b) -> {
            if (a[2] == b[2]) {
               if (a[0] == b[0]) {
                  return a[1] - b[1];
               }
               return a[0] - b[0];
            }
            return a[2] - b[2];
         });

         int[] target = eatList.get(0);
         int targetX = target[0];
         int targetY = target[1];
         int targetDist = target[2];

         map[targetX][targetY] = 0;
         sharkX = targetX;
         sharkY = targetY;
         eatCount++;

         if (eatCount == sharkSize) {
            sharkSize++;
            eatCount = 0;
         }

         moveCount += targetDist;
      }
   }

   static int[] find() {
      for (int i = 0; i < N; i++) {
         for (int j = 0; j < N; j++) {
            if (map[i][j] == 9) {
               map[i][j] = 0;
               return new int[]{i, j};
            }
         }
      }
      return null;
   }
}


```

<br>
<br>

### â–«ï¸ ë‘ ë²ˆì§¸ ì•Œê³ ë¦¬ì¦˜
- ```í’€ì´ ì‹œê°„ : 28ë¶„```
1. N ì…ë ¥ë°›ê¸°
2. ë°°ì—´ ì…ë ¥ë°›ê¸°
3. ê·¸ë¦¬ë”” ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ í’€ì´
    - ê·¸ë¦¬ë””í•˜ê²Œ ìƒì–´ê°€ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¨¹ì´ ì¤‘ ê°€ì¥ ê°€ê¹Œìš´ ë¨¹ì´ë¥¼ ì„ íƒí•˜ë„ë¡ ë°˜ë³µ
    - ë‹¨, ë‚´ë¶€ì ìœ¼ë¡œ BFSë¥¼ ì ìš©í•¨.

```java
//ì²« í’€ì´ ì†ŒìŠ¤ì½”ë“œ
package HayanLee.ì‚¼ì„±ì „ìê¸°ì¶œ.Q46_ì•„ê¸°ìƒì–´;

import java.util.*;

class BabyShark_Greedy {
   static int[][] map;
   static int N;
   static int[] dx = {-1, 1, 0, 0};
   static int[] dy = {0, 0, -1, 1};

   static int startX;
   static int startY;

   public static void main(String[] args) {
      Scanner scanner = new Scanner(System.in);
      N = scanner.nextInt();
      map = new int[N][N];

      // ë°°ì—´ ì…ë ¥ ë°›ê¸°
      startX = 0;
      startY = 0;
      for (int i = 0; i < N; i++) {
         for (int j = 0; j < N; j++) {
            map[i][j] = scanner.nextInt();
            if (map[i][j] == 9) {
               startX = i;
               startY = j;
               map[i][j] = 0;
            }
         }
      }

      int result = 0;
      int sharkSize = 2;
      int count = 0;

      while (true) {
         int[] nearestFood = find(startX, startY, sharkSize);
         if (nearestFood == null) {
            break;
         }
         int targetX = nearestFood[0];
         int targetY = nearestFood[1];
         int dist = nearestFood[2];

         result += dist;
         map[targetX][targetY] = 0;
         count++;

         if (count == sharkSize) {
            sharkSize++;
            count = 0;
         }

         startX = targetX;
         startY = targetY;
      }

      System.out.println(result);
   }

   static int[] find(int startX, int startY, int sharkSize) {
      boolean[][] visited = new boolean[N][N];
      Queue<int[]> queue = new LinkedList<>();
      queue.add(new int[]{startX, startY, 0});
      visited[startX][startY] = true;

      int[] nFood = null;
      int minDistance = Integer.MAX_VALUE;

      while (!queue.isEmpty()) {
         int[] now = queue.poll();
         int x = now[0];
         int y = now[1];
         int dist = now[2];

         if (map[x][y] != 0 && map[x][y] < sharkSize) {
            if (dist < minDistance) {
               nFood = new int[]{x, y, dist};
               minDistance = dist;
            }
            if (dist == minDistance) {
               if (x < nFood[0] || (x == nFood[0] && y < nFood[1])) {
                  nFood = new int[]{x, y, dist};
               }
            }
         }

         for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if (nx >= 0 && nx < N && ny >= 0 && ny < N && !visited[nx][ny] && map[nx][ny] <= sharkSize) {
               queue.add(new int[]{nx, ny, dist + 1});
               visited[nx][ny] = true;
            }
         }
      }
      return nFood;
   }
}
```
<br>
<br>

### â–«ï¸ ì„¸ ë²ˆì§¸ ì•Œê³ ë¦¬ì¦˜
- ```í’€ì´ ì‹œê°„ : 13ë¶„```
1. N ì…ë ¥ë°›ê¸°
2. ë°°ì—´ ì…ë ¥ë°›ê¸°
3. ìš°ì„ ìˆœìœ„ í êµ¬í˜„
   - Comparableë¡œ Node ìƒì„±í•˜ê¸°
   - ìš°ì„ ìˆœìœ„ íë¡œ íƒìƒ‰
     - ìƒì–´ ìœ„ì¹˜ë¶€í„° ì‹œì‘í•´ì„œ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ë¥¼ ì°¾ê¸° ìœ„í•´ íƒìƒ‰
     - ìƒì–´ê°€ ë¨¹ì„ ìˆ˜ ìˆëŠ” ë¬¼ê³ ê¸°ë¥¼ ë°œê²¬í•˜ë©´ â¡ï¸ í•´ë‹¹ ë¬¼ê³ ê¸°ê¹Œì§€ì˜ ê±°ë¦¬, ì‹œê°„ ê³„ì‚° ë° ë¨¹ì€ íšŸìˆ˜++
     - ìƒì–´ í¬ê¸°++
     - ì´ ê±¸ë¦° ì‹œê°„ìœ¼ë¡œ result êµ¬ì„±

```java
//ì²« í’€ì´ ì†ŒìŠ¤ì½”ë“œ
package HayanLee.ì‚¼ì„±ì „ìê¸°ì¶œ.Q46_ì•„ê¸°ìƒì–´;

import java.util.*;

class Node implements Comparable<Node> {
   int x, y, distance;

   Node(int x, int y, int distance) {
      this.x = x;
      this.y = y;
      this.distance = distance;
   }

   @Override
   public int compareTo(Node other) {
      if (this.distance == other.distance) {
         if (this.x == other.x)
            return Integer.compare(this.y, other.y);
         return Integer.compare(this.x, other.x);
      }
      return Integer.compare(this.distance, other.distance);
   }
}

public class BabyShark_PQ {
   static int[][] map;
   static int size = 2;
   static int eat = 0;
   static int result = 0;
   static int[] dx = {-1, 0, 1, 0};
   static int[] dy = {0, -1, 0, 1};
   static int N;
   static int startX;
   static int startY;

   public static void main(String[] args) {
      Scanner sc = new Scanner(System.in);
      N = sc.nextInt();
      map = new int[N][N];

      startX = 0;
      startY = 0;

      for (int i = 0; i < N; i++) {
         for (int j = 0; j < N; j++) {
            map[i][j] = sc.nextInt();
            if (map[i][j] == 9) {
               startX = i;
               startY = j;
               map[i][j] = 0;
            }
         }
      }

      while (true) {
         Node target = find(startX, startY);
         if (target == null) break;
         startX = target.x;
         startY = target.y;
         result += target.distance;
         eat++;
         if (eat == size) {
            size++;
            eat = 0;
         }
         map[startX][startY] = 0;
      }
      System.out.println(result);
   }

   static Node find(int x, int y) {
      PriorityQueue<Node> pq = new PriorityQueue<>();
      boolean[][] visited = new boolean[N][N];
      pq.offer(new Node(x, y, 0));
      visited[x][y] = true;

      while (!pq.isEmpty()) {
         Node now = pq.poll();
         if (map[now.x][now.y] != 0 && map[now.x][now.y] < size) {
            return now;
         }

         for (int i = 0; i < 4; i++) {
            int nx = now.x + dx[i];
            int ny = now.y + dy[i];
            if (nx >= 0 && nx < N && ny >= 0 && ny < N && !visited[nx][ny] && map[nx][ny] <= size) {
               visited[nx][ny] = true;
               pq.offer(new Node(nx, ny, now.distance + 1));
            }
         }
      }
      return null;
   }
}
```

### â–«ï¸ ìµœì¢… í’€ì´
- BabySharkBFS.java
- BabyShark_Greedy.java
- BabyShark_PQ.java

![image](https://github.com/hayannn/2L24-Algo-Study/assets/102213509/77240278-4f2f-4d63-8041-9dcfdbc83610)

![image](https://github.com/hayannn/2L24-Algo-Study/assets/102213509/293aca8d-9671-4665-b368-1152254c0ecf)

![image](https://github.com/hayannn/2L24-Algo-Study/assets/102213509/51c47a54-2f76-4df0-9944-e6091eb7de43)

![image](https://github.com/hayannn/2L24-Algo-Study/assets/102213509/d522a7a4-07af-4f00-b296-d86f61e044e2)

![image](https://github.com/hayannn/2L24-Algo-Study/assets/102213509/a393c638-d62c-421c-bb93-e431fc23bf16)

![image](https://github.com/hayannn/2L24-Algo-Study/assets/102213509/de89bf64-0898-4c15-8920-55679b742fc6)

<br>

- ìµœì¢…ì ìœ¼ë¡œ ```ìš°ì„ ìˆœìœ„ í```ë¥¼ ì‚¬ìš©í•´ ë©”ëª¨ë¦¬ë¥¼ ìµœëŒ€í•œ ì¤„ì„!

![image](https://github.com/hayannn/2L24-Algo-Study/assets/102213509/5185a14c-9304-45ba-9166-f15337258d44)


# ì–´ë‘ìš´ ê¸¸

|   ì •ë³´    |               ë‚´ìš©                |
|:-----------:|:-------------------------------:|
|   ë‚œì´ë„   |              ğŸŸ¢ğŸŸ¢âšª              |
|  í’€ì´ ì‹œê°„  |               40ë¶„               |
|  ì‹œê°„ ì œí•œ  |               1ì´ˆ                |
| ë©”ëª¨ë¦¬ ì œí•œ  |              128MB              |
| ê¸°ì¶œ | University of Ulm Local Contest |

<br>
<br>

### â–«ï¸ ë¬¸ì œ ì •ë³´
í•œ ë§ˆì„ì€ Nê°œì˜ ì§‘ê³¼ Mê°œì˜ ë„ë¡œë¡œ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤. <br>
ê° ì§‘ì€ 0ë²ˆë¶€í„° N - 1ë²ˆê¹Œì§€ì˜ ë²ˆí˜¸ë¡œ êµ¬ë¶„ë©ë‹ˆë‹¤. <br>
ëª¨ë“  ë„ë¡œì—ëŠ” ê°€ë¡œë“±ì´ êµ¬ë¹„ë˜ì–´ ìˆëŠ”ë°, íŠ¹ì •í•œ ë„ë¡œì˜ ê°€ë¡œë“±ì„ í•˜ë£¨ ë™ì•ˆ ì¼œê¸° ìœ„í•œ ë¹„ìš©ì€ í•´ë‹¹ ë„ë¡œì˜ ê¸¸ì´ì™€ ë™ì¼í•©ë‹ˆë‹¤. <br>
ì˜ˆë¥¼ ë“¤ì–´ 2ë²ˆ ì§‘ê³¼ 3ë²ˆ ì§‘ ì‚¬ì´ë¥¼ ì—°ê²°í•˜ëŠ” ê¸¸ì´ê°€ 7ì¸ ë„ë¡œê°€ ìˆë‹¤ê³  í•´ë´…ì‹œë‹¤. <br>
í•˜ë£¨ ë™ì•ˆ ì´ ê°€ë¡œë“±ì„ ì¼œê¸° ìœ„í•œ ë¹„ìš©ì€ 7ì´ ë©ë‹ˆë‹¤. <br><br>
ì •ë¶€ì—ì„œëŠ” ì¼ë¶€ ê°€ë¡œë“±ì„ ë¹„í™œì„±í™”í•˜ë˜, ë§ˆì„ì— ìˆëŠ” ì„ì˜ì˜ ë‘ ì§‘ì— ëŒ€í•˜ì—¬ ê°€ë¡œë“±ì´ ì¼œì§„ ë„ë¡œë§Œìœ¼ë¡œë„ ì˜¤ê°ˆ ìˆ˜ ìˆë„ë¡ ë§Œë“¤ê³ ì í•©ë‹ˆë‹¤. <br>
ê²°ê³¼ì ìœ¼ë¡œ ì¼ë¶€ ê°€ë¡œë“±ì„ ë¹„í™œì„±í™”í•˜ì—¬ ìµœëŒ€í•œ ë§ì€ ê¸ˆì•¡ì„ ì ˆì•½í•˜ê³ ì í•©ë‹ˆë‹¤. <br>
ë§ˆì„ì˜ ì§‘ê³¼ ë„ë¡œ ì •ë³´ê°€ ì£¼ì–´ì¡Œì„ ë•Œ, ì¼ë¶€ ê°€ë¡œë“±ì„ ë¹„í™œì„±í™”í•˜ì—¬ ì ˆì•½í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ê¸ˆì•¡ì„ ì¶œë ¥í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì„¸ìš”.

<br>
<br>

### â–«ï¸ ì…ì¶œë ¥ ì¡°ê±´
- ì…ë ¥
    - ì²«ì§¸ ì¤„ì— ì§‘ì˜ ìˆ˜ N(1<=N<=200,000)ê³¼ ë„ë¡œì˜ ìˆ˜ M(N-1<=N,M<=200,000)ì´ ì£¼ì–´ì§‘ë‹ˆë‹¤. <br>
      ë‹¤ìŒ Mê°œì˜ ì¤„ì— ê±¸ì³ ê° ë„ë¡œì— ëŒ€í•œ ì €ë³´ X, Y, Zê°€ ì£¼ì–´ì§€ë©°, ê³µë°±ìœ¼ë¡œ êµ¬ë¶„í•©ë‹ˆë‹¤. (0<=X,Y<N) <br>
      ì´ëŠ” Xë²ˆ ì§‘ê³¼ Yë²ˆ ì§‘ ì‚¬ì´ì— ì–‘ë°©í–¥ ë„ë¡œê°€ ìˆìœ¼ë©°, ê·¸ ê¸¸ì´ê°€ Zë¼ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤. <br>
      ë‹¨, Xì™€ Yê°€ ë™ì¼í•œ ê²½ìš°ëŠ” ì—†ìœ¼ë©° ë§ˆì„ì„ êµ¬ì„±í•˜ëŠ” ëª¨ë“  ë„ë¡œì˜ ê¸¸ì´ í•©ì€ 2<sup>31</sup>ë³´ë‹¤ ì‘ìŠµë‹ˆë‹¤.

- ì¶œë ¥
    - ì²«ì§¸ ì¤„ì— ì¼ë¶€ ê°€ë¡œë“±ì„ ë¹„í™œì„±í™”í•˜ì—¬ ì ˆì•½í•  ìˆ˜ ì‡ëŠ” ìµœëŒ€ ê¸ˆì•¡ì„ ì¶œë ¥í•©ë‹ˆë‹¤.

<br>
<br>

### â–«ï¸ ì…ì¶œë ¥ ì˜ˆì‹œ
```java
//ì…ë ¥
7 11
0 1 7
0 3 5
1 2 8
1 3 9
1 4 7
2 4 5
3 4 15
3 5 6
4 5 8
4 6 9
5 6 11
```
```java
//ì¶œë ¥
51
```

<br>
<br>

### â–«ï¸ ì•Œê³ ë¦¬ì¦˜
- ```í’€ì´ ì‹œê°„ : ë¶„```

1. Nê³¼ M ì…ë ¥ë°›ê¸°
2. ë°°ì—´ ì…ë ¥ë°›ê¸°
3. í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ êµ¬í˜„
    - Union Find ì—°ì‚° ìˆ˜í–‰
    - ê±°ë¦¬ê°€ ì§§ì€ ê²ƒì´ ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°–ë„ë¡ í•˜ê¸°

```java
//ì²« í’€ì´ ì†ŒìŠ¤ì½”ë“œ
package HayanLee.ê·¸ë˜í”„ì´ë¡ .ê¸°ì¶œë¬¸ì œ.Q43_ì–´ë‘ìš´ê¸¸;

import java.util.*;

class Edge implements Comparable<Edge> {
    private int A;
    private int B;
    private int distance;

    public Edge(int A, int B, int distance) {
        this.A = A;
        this.B = B;
        this.distance = distance;
    }

    public int getDistance() {
        return this.distance;
    }

    public int getA() {
        return this.A;
    }

    public int getB() {
        return this.B;
    }

    @Override
    public int compareTo(Edge other) {
        return this.distance - other.distance;
    }
}

public class DarkRoad {
    static int[] P;
    static int N;
    static int M;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        N = sc.nextInt();
        M = sc.nextInt();

        P = new int[N];
        for (int i = 0; i < N; i++) {
            P[i] = i;
        }

        PriorityQueue<Edge> pq = new PriorityQueue<>();
        int total = 0;

        for (int i = 0; i < M; i++) {
            int A = sc.nextInt();
            int B = sc.nextInt();
            int distance = sc.nextInt();
            pq.add(new Edge(A, B, distance));
            total += distance;
        }

        int nowDistance = kruskal(pq);

        int result = total - nowDistance;
        System.out.println(result);
    }

    static int kruskal(PriorityQueue<Edge> pq) {
        int savedCost = 0;

        while (!pq.isEmpty()) {
            Edge edge = pq.poll();
            int rootA = find(edge.getA());
            int rootB = find(edge.getB());

            if (rootA != rootB) {
                union(rootA, rootB);
                savedCost += edge.getDistance();
            }
        }

        return savedCost;
    }

    static void union(int x, int y) {
        x = find(x);
        y = find(y);
        if (x != y) {
            P[y] = x;
        }
    }

    static int find(int x) {
        if (P[x] == x) {
            return x;
        }
        return P[x] = find(P[x]);
    }
}
```

<br>
<br>

### â™»ï¸ Code Refactoring
- ```Comparable``` ì¸í„°í˜ì´ìŠ¤ â¡ï¸ ì´ê±¸ ì§ì ‘ êµ¬í˜„í•˜ì§€ ì•Šê³  Compartor ë°”ë¡œ ì‚¬ìš©
- ```union``` ë©”ì„œë“œë¥¼ ë” ê°„ê²°í•˜ê²Œ ì¤„ì´ê¸°

```java
package HayanLee.ê·¸ë˜í”„ì´ë¡ .ê¸°ì¶œë¬¸ì œ.Q43_ì–´ë‘ìš´ê¸¸;

import java.util.*;

class DarkRoad2 {
    static int[] P;
    static int N;
    static int M;

    static class Edge {
        int A;
        int B;
        int distance;

        public Edge(int A, int B, int distance) {
            this.A = A;
            this.B = B;
            this.distance = distance;
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        N = sc.nextInt();
        M = sc.nextInt();

        P = new int[N];
        for (int i = 0; i < N; i++) {
            P[i] = i;
        }

        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.distance));
        int total = 0;

        for (int i = 0; i < M; i++) {
            int A = sc.nextInt();
            int B = sc.nextInt();
            int distance = sc.nextInt();
            pq.add(new Edge(A, B, distance));
            total += distance;
        }

        int nowDistance = kruskal(pq, N);

        int result = total - nowDistance;
        System.out.println(result);
    }

    static int kruskal(PriorityQueue<Edge> pq, int N) {
        int savedCost = 0;

        while (!pq.isEmpty()) {
            Edge edge = pq.poll();
            int rootA = find(edge.A);
            int rootB = find(edge.B);

            if (rootA != rootB) {
                union(rootA, rootB);
                savedCost += edge.distance;
            }
        }

        return savedCost;
    }

    static void union(int x, int y) {
        P[find(y)] = find(x);
    }

    static int find(int x) {
        if (P[x] == x) {
            return x;
        }
        return P[x] = find(P[x]);
    }
}
```

<br>
<br>

### â–«ï¸ ìµœì¢… í’€ì´
- DarkRoad.java
- DarkRoad2.java

<img width="174" alt="image" src="https://github.com/hayannn/2L24-Algo-Study/assets/102213509/b0eb793d-5ba3-44f3-90d9-686d49502427">

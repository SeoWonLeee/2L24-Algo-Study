# **🏷️  DFS/BFS; 사전 학습 (2)**

**1. 그래프**
  - 그래프의 기본 구조 - 노드(=정점)와 간선
  - 그래프 탐색 - 하나의 노드를 시작으로 다수의 노드를 방문하는 것
  - 두 노드가 간선으로 연결되어 있다. → ‘두 노드는 인접하다’
  - 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
  - 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식
<br/>

**2. 인접 행렬 방식 Adjacency Matrix**
- 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식
- 예를 들어, 노드 A와 노드 B가 연결되어 있다면 인접 행렬에서는 해당 위치에 연결되어 있음을 표시하고, 연결되어 있지 않은 경우에는 무한의 비용을 설정한다. 
  <br/> 이를 자바로 구현하려면 2차원 배열을 사용하고, 연결이 되어 있지 않은 노드끼리는 무한의 비용으로 초기화해야 한다.
  <br/>

    ```java
    public class AdjacencyMatrix {
        int[][] graph; // 그래프를 표현할 2차원 배열
        int inf = 999999999; // 무한의 비용
    
        public AdjacencyMatrix(int n) {
            // n은 노드의 수
            graph = new int[n][n]; // n x n 크기의 2차원 배열 생성
    
            // 모든 요소를 무한의 비용으로 초기화
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    graph[i][j] = inf;
                }
            }
        }
    
        public void addEdge(int from, int to, int cost) {
            // from 노드에서 to 노드로의 연결을 추가하고 cost를 설정
            graph[from][to] = cost;
        }
    }
    
    ```
  + 연결되어 있지 않은 경우에 무한의 비용을 설정하는 이유
    
    1.  **알고리즘 특성과 호환성** : 많은 그래프 알고리즘들이 무한대를 '경로가 없음'이나 '불가능'을 나타내는 값으로 취급함. 연결되지 않은 노드간의 거리를 무한대로 설정함으로써 알고리즘이 이러한 상태를 올바르게 처리할 수 있음.
    2.  **비용으로서의 의미** : 무한의 비용은 실제로 연결이 불가능한 경우를 의미함. 예를 들어, 어떤 두 지점 간에 도로나 경로가 없는 경우, 그 거리나 비용은 무한대로 간주됨.
    3.  **안전한 초기화** : 무한대를 사용하면 코드를 더 안전하게 초기화할 수 있음. 특히 큰 값을 선택함으로써 의도치 않은 오류 방지.
<br/>

**3. 인접 리스트 방식 Adjacency List**
- 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장하는 방식
- 예를 들어, 노드 A와 노드 B가 연결되어 있다면, A의 연결 리스트에 B가 저장되고, B의 연결 리스트에 A가 저장된다.
  <br/> 이를 자바로 구현하려면, 각 노드마다 연결된 노드들을 리스트로 저장하고, 연결이 없는 경우에는 빈 리스트로 표현한다.
    
    ```java
    import java.util.ArrayList;
    import java.util.List;
    
    public class AdjacencyList {
        List<List<Integer>> graph; // 그래프를 표현할 인접 리스트
    
        // 그래프 초기화
        public AdjacencyList(int n) {
            graph = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                graph.add(new ArrayList<>()); // 각 노드에 대한 연결 리스트 생성
            }
        }
    
        // 간선 추가
        public void addEdge(int from, int to) {
            // 무방향 그래프의 경우 양방향으로 연결
            graph.get(from).add(to); // from 노드에서 to 노드로의 연결을 추가
            graph.get(to).add(from); // to 노드에서 from 노드로의 연결도 추가
        }
    
        public static void main(String[] args) {
            int n = 3; // 노드의 수
            AdjacencyList graph = new AdjacencyList(n);
    
            // 노드 간 간선 추가
            graph.addEdge(0, 1);
            graph.addEdge(0, 2);
    
            // 인접 리스트 출력
            for (int i = 0; i < n; i++) {
                System.out.print("Node " + i + " is connected to: ");
                for (int neighbor : graph.graph.get(i)) {
                    System.out.print(neighbor + " ");
                }
                System.out.println();
            }
        }
    }
    
    ```
<br/>

**4. 인접 행렬과 인접 리스트의 차이**
  - 메모리 측면
    - 인접 행렬 : 모든 관계를 저장하므로 노드 개수가 많을수록 메모리가 불필요하게 낭비
    - 인접 리스트 : 연결된 정보만을 저장하기 때문에 메로리를 효율적으로 사용
  - 속도 측면
    - 인접 리스트는 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림 (인접 리스트는 연결된 데이터를 하나씩 확인해야 하기 때문)

  - 예를 들어, 그래프에서 노드 1과 노드 7이 연결되어 있는 상황
    인접 행렬 방식에서는 graph [1] [7]만 확인하는 반면, 인접 리스트 방식에서는 노드 1에 대한 인접 리스트를 앞에서부터 차례대로 확인.
<br/>

5. 인접 리스트 방식은 각 노드마다 그에 연결된 노드들을 리스트로 저장한다. 이 때문에 인접 리스트의 크기는 노드의 수와 해당 노드의 연결된 노드 수에 의해 결정된다. 따라서 인접 행렬 방식에 비해 메모리 공간을 더 효율적으로 사용한다.
<br/> <br/> 그러나, 인접 행렬은 그래프의 연결 상태를 2차원 배열로 나타낸다. 이 배열의 크기는 노드의 수에 따라 결정되며, 모든 노드의 쌍에 대해 연결 여부를 표시한다. 따라서 노드의 수가 많아지면 인접 행렬의 크기가 크게 증가하며, 연결되지 않은 노드들 사이에도 메모리 공간이 할당된다.

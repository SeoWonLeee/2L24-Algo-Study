### 3. λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ λ™μ‘ μ›λ¦¬
<br/>

### π“Β κ°„λ‹¨ν• λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦ - μ¶λ° λ…Έλ“ 1μ—μ„ λ‹¤λ¥Έ λ¨λ“  λ…Έλ“λ΅ κ°€λ” μµλ‹¨ κ²½λ΅λ¥Ό κµ¬ν•λ” μμ  <br/> 
- μ΄κΈ° μƒνƒμ—μ„λ” λ‹¤λ¥Έ λ¨λ“  λ…Έλ“λ΅ κ°€λ” μµλ‹¨ κ±°λ¦¬ β€λ¬΄ν•β€™μΌλ΅ μ΄κΈ°ν™”
  <br/>

  <img width="280" alt="λ‹¤μµμ¤νΈλΌ λ™μ‘ μ›λ¦¬" src="https://github.com/SeoWonLeee/2L24-Algo-Study/assets/148112372/04177d48-6288-4fde-9b4d-a10047b41878">
  <br/>
  
  <img width="550" alt="α„€α…΅α†«α„ƒα…΅α†«α„’α…΅α†« α„ƒα…΅α„‹α…µα†¨α„‰α…³α„α…³α„…α…΅ α„‹α…΅α†―α„€α…©α„…α…µα„α…³α†·" src="https://github.com/SeoWonLeee/2L24-Algo-Study/assets/148112372/406690cc-9c1b-4405-8014-67a992d6c5a6">
  <br/>
      
    - β€λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ κ°€μ¥ μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ λ…Έλ“λ¥Ό μ„ νƒν•λ” κ³Όμ •β€™ λ°λ³µμ„ ν†µν•΄ μ„ νƒλ λ…Έλ“λ” β€μµλ‹¨ κ±°λ¦¬β€™κ°€ μ™„μ „ν μ„ νƒλ λ…Έλ“ <br/> β†’ λ” μ΄μƒ μµλ‹¨ κ±°λ¦¬ μ¤„μ–΄λ“¤μ§€ μ•μ
    - ν• λ² μ„ νƒλ λ…Έλ“λ” μµλ‹¨ κ±°λ¦¬κ°€ κ°μ† β
    - β€ν• λ‹¨κ³„λ‹Ή ν•λ‚μ λ…Έλ“μ— λ€ν• μµλ‹¨ κ±°λ¦¬λ¥Ό ν™•μ‹¤ν μ°Ύλ” κ²ƒμΌλ΅ μ΄ν•΄β€
    - λ§μ§€λ§‰ λ…Έλ“μ— λ€ν•΄μ„λ” ν•΄λ‹Ή λ…Έλ“λ¥Ό κ±°μ³ λ‹¤λ¥Έ λ…Έλ“λ΅ κ°€λ” κ²½μ°λ¥Ό ν™•μΈν•  ν•„μ” β
<br/>

### π“ κ°„λ‹¨ν• λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦ - μ•κ³ λ¦¬μ¦μ„ κ·Έλ€λ΅ μ½”λ“ κµ¬ν„

- λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ μ‹κ°„λ³µμ΅λ„ : $O(V^2)$  (Vλ” λ…Έλ“μ κ°μ)
    - μ΄ $O(V)$λ²μ— κ±Έμ³μ„ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό λ§¤λ² μ„ ν• νƒμƒ‰ν•΄μ•Ό ν•κ³ , ν„μ¬ λ…Έλ“μ™€ μ—°κ²°λ λ…Έλ“λ¥Ό λ§¤λ² λ¨λ‘ ν™•μΈν•κΈ° λ•λ¬Έ
- μ§κ΄€μ μ΄κ³  μ‰½κ² μ΄ν•΄ κ°€λ¥
    1. μ²μμ— κ° λ…Έλ“μ— λ€ν• μµλ‹¨ κ±°λ¦¬λ¥Ό λ‹΄λ” 1μ°¨μ› λ¦¬μ¤νΈλ¥Ό μ„ μ–Έ
    2. λ‹¨κ³„λ§λ‹¤ β€λ°λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό μ„ νƒβ€™ν•κΈ° μ„ν•΄ λ§¤ λ‹¨κ³„λ§λ‹¤ 1μ°¨μ› λ¦¬μ¤νΈμ λ¨λ“  μ›μ†λ¥Ό ν™•μΈ <br/> (μμ°¨ νƒμƒ‰)
<br/>

```java
import java.util.*;

public class Main {
    static final int INF = (int) 1e9; // λ¬΄ν•μ„ μλ―Έν•λ” κ°’μΌλ΅ 10μ–µμ„ μ„¤μ •
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt(); // λ…Έλ“μ κ°μ μ…λ ¥
        int m = scanner.nextInt(); // κ°„μ„ μ κ°μ μ…λ ¥
        int start = scanner.nextInt(); // μ‹μ‘ λ…Έλ“ λ²νΈ μ…λ ¥
        
        // κ° λ…Έλ“μ— μ—°κ²°λμ–΄ μλ” λ…Έλ“μ— λ€ν• μ •λ³΄λ¥Ό λ‹΄λ” λ¦¬μ¤νΈλ¥Ό λ§λ“¤κΈ°
        List<List<Edge>> graph = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }
        
        // λ°©λ¬Έν• μ μ΄ μλ”μ§€ μ²΄ν¬ν•λ” λ©μ μ λ¦¬μ¤νΈλ¥Ό λ§λ“¤κΈ°
        boolean[] visited = new boolean[n + 1];
        // μµλ‹¨ κ±°λ¦¬ ν…μ΄λΈ”μ„ λ¨λ‘ λ¬΄ν•μΌλ΅ μ΄κΈ°ν™”
        int[] distance = new int[n + 1];
        Arrays.fill(distance, INF);
        
        // λ¨λ“  κ°„μ„  μ •λ³΄λ¥Ό μ…λ ¥λ°›κΈ°
        for (int i = 0; i < m; i++) {
            int a = scanner.nextInt();
            int b = scanner.nextInt();
            int c = scanner.nextInt();
            // aλ² λ…Έλ“μ—μ„ bλ² λ…Έλ“λ΅ κ°€λ” λΉ„μ©μ΄ cλΌλ” μλ―Έ
            graph.get(a).add(new Edge(b, c));
        }
        
        // λ‹¤μµμ¤νΈλΌ μ•κ³ λ¦¬μ¦μ„ μν–‰
        dijkstra(start, graph, visited, distance);
        
        // λ¨λ“  λ…Έλ“λ΅ κ°€κΈ° μ„ν• μµλ‹¨ κ±°λ¦¬λ¥Ό μ¶λ ¥
        for (int i = 1; i <= n; i++) {
            // λ„λ‹¬ν•  μ μ—†λ” κ²½μ°, λ¬΄ν•(INFINITY)μ΄λΌκ³  μ¶λ ¥
            if (distance[i] == INF) {
                System.out.println("INFINITY");
            } 
            // λ„λ‹¬ν•  μ μλ” κ²½μ° κ±°λ¦¬λ¥Ό μ¶λ ¥
            else {
                System.out.println(distance[i]);
            }
        }
    }
    
    // λ°©λ¬Έν•μ§€ μ•μ€ λ…Έλ“ μ¤‘μ—μ„, κ°€μ¥ μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ λ…Έλ“μ λ²νΈλ¥Ό λ°ν™
    public static int getSmallestNode(int[] distance, boolean[] visited) {
        int minDistance = INF;
        int index = 0; // κ°€μ¥ μµλ‹¨ κ±°λ¦¬κ°€ μ§§μ€ λ…Έλ“(μΈλ±μ¤)
        for (int i = 1; i < distance.length; i++) {
            if (distance[i] < minDistance && !visited[i]) {
                minDistance = distance[i];
                index = i;
            }
        }
        return index;
    }
    
    public static void dijkstra(int start, List<List<Edge>> graph, boolean[] visited, int[] distance) {
        // μ‹μ‘ λ…Έλ“μ— λ€ν•΄μ„ μ΄κΈ°ν™”
        distance[start] = 0;
        visited[start] = true;
        for (Edge edge : graph.get(start)) {
            distance[edge.to] = edge.cost;
        }
        // μ‹μ‘ λ…Έλ“λ¥Ό μ μ™Έν• μ „μ²΄ n - 1κ°μ λ…Έλ“μ— λ€ν•΄ λ°λ³µ
        for (int i = 0; i < graph.size() - 1; i++) {
            // ν„μ¬ μµλ‹¨ κ±°λ¦¬κ°€ κ°€μ¥ μ§§μ€ λ…Έλ“λ¥Ό κΊΌλ‚΄μ„, λ°©λ¬Έ μ²λ¦¬
            int now = getSmallestNode(distance, visited);
            visited[now] = true;
            // ν„μ¬ λ…Έλ“μ™€ μ—°κ²°λ λ‹¤λ¥Έ λ…Έλ“λ¥Ό ν™•μΈ
            for (Edge edge : graph.get(now)) {
                int cost = distance[now] + edge.cost;
                // ν„μ¬ λ…Έλ“λ¥Ό κ±°μ³μ„ λ‹¤λ¥Έ λ…Έλ“λ΅ μ΄λ™ν•λ” κ±°λ¦¬κ°€ λ” μ§§μ€ κ²½μ°
                if (cost < distance[edge.to]) {
                    distance[edge.to] = cost;
                }
            }
        }
    }
    
    static class Edge {
        int to;
        int cost;
        
        public Edge(int to, int cost) {
            this.to = to;
            this.cost = cost;
        }
    }
}
```

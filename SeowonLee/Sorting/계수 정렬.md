## **🏷️ 정렬 - 계수 정렬**

- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
- ‘데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때’만 사용 가능
- 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용
→ 계수 정렬을 이용할 때 ‘모든 범위를 담을 수 있는 크기의 리스트(배열)을 선언’해야 하기 때문
- 직접 데이터의 값을 비교한 뒤에 위치를 변경하며 정렬하는 방식이 아님 (비교 기반의 정렬 알고리즘 ❌)
- 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담음
- 데이터의 크기가 제한되어 있을 때에 한해서 데이터의 개수가 매우 많더라도 빠르게 동작
<br/>

**1. 계수 정렬 수행 예시** <br/>
<br/> 
&nbsp;&nbsp; ① 먼저, 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한다. <br/>
&nbsp;&nbsp; ② 처음에는 리스트의 모든 데이터가 0이 되도록 초기화한다. <br/>
&nbsp;&nbsp; ③ 그 다음 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시킨다.
<br/> <br/>

  - 데이터의 범위만 한정되어 있다면 효과적으로 사용할 수 있으면 항상 빠르게 동작한다.
  - 현존하는 정렬 알고리즘 중에서 기수 정렬과 더불어 가장 빠르다.

    <img width="440" alt="계수" src="https://github.com/SeoWonLeee/2L24-Algo-Study/assets/148112372/aef7b2cb-81c6-4561-8d7b-7bddf5002236"> <br/>

    ```java
    import java.util.Arrays;

    public class CountingSort {
      public static void main(String[] args) {
          // 정렬할 배열 선언
          int[] array = {7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2};

          // 배열에서 최댓값을 찾아 count 배열 크기 설정
          int max = Arrays.stream(array).max().getAsInt();
          int[] count = new int[max + 1];

          // 각 데이터에 해당하는 인덱스의 값 증가
          for (int i = 0; i < array.length; i++) {
            count[array[i]]++;
          }

          // 리스트에 기록된 정렬 정보 확인하고 출력
          for (int i = 0; i < count.length; i++) {
              for (int j = 0; j < count[i]; j++) {
                  System.out.print(i + " "); // 해당 인덱스 값이 등장한 횟수만큼 출력
              }
          }
       }
    }
    ```
<br/>

**2. 계수 정렬의 시간 복잡도 - $O(N + K)$**
  - 모든 데이터가 양의 정수인 상황에서 데이터의 개수 N, 데이터 중 최대값의 크기 K
  - 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킨다.
  - 추후에 리스트의 각 인덱스에 해당하는 값들을 확인할 때 데이터 중 최댓값이 크기만큼 반복을 수행한다.
<br/>

**3. 계수 정렬의 공간 복잡도 - $O(N+K)$**
  - 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합하다.
  - 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리하며 항상 사용할 수 없다.
  - 조건만 만족한다면 계수 정렬은 정렬해야 하는 데이터의 개수가 매우 많을 때에도 효과적으로 사용할 수 있다.

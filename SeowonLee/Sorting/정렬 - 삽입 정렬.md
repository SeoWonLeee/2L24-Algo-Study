## **🏷️ 정렬 - 삽입 정렬**

- ‘데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하면 어떨까?’
- **“삽입 정렬** : 특정한 데이터를 적절한 위치에 ‘삽입’한다는 의미”
- 동작 원리를 직관적으로 이해하기 쉬운 알고리즘
- 선택 정렬에 비해 실행 시간 측면에서 더 효율적인 알고리즘
- 필요할 때만 위치를 바꾸므로 ‘데이터가 거의 정렬되어 있을 때’ 훨씬 효율적
- 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입
- 두 번째 데이터부터 시작 → 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문
<br/>

**1. 삽입 정렬 수행 예시**
   - 정렬이 이루어진 원소는 항상 ‘오름차순’으로 유지한다.
   - 삽입 정렬에서는 특정한 데이터가 삽입될 위치를 선정할 때 (삽입될 위치를 찾기 위하여 왼쪽으로 한 칸식 이동할 때), <br/> 삽입될 데이터보다 작은 데이터를 만나면 그 위치에서 멈추면 된다.

     <img width="440" alt="삽입" src="https://github.com/SeoWonLeee/2L24-Algo-Study/assets/148112372/fb904a82-16af-4295-808c-1f7bd7b34de8"> <br/>

     ```java
     public class InsertionSort {
       public static void main(String[] args) {
       // 정렬할 숫자들을 배열에 저장
           int[] array = {7, 5, 9, 0, 3, 1, 6, 2, 4, 8};

           // 삽입 정렬 알고리즘을 사용하여 배열을 정렬
           for (int i = 1; i < array.length; i++) {
           // 현재 위치의 숫자를 적절한 위치에 삽입
               for (int j = i; j > 0; j--) {
               // 현재 숫자가 이전 숫자보다 작으면 두 숫자의 위치 교환
                   if (array[j] < array[j - 1]) {
                       int temp = array[j];
                       array[j] = array[j - 1];
                       array[j - 1] = temp;
                   } else {
                   // 자기보다 작은 데이터를 만나면 반복을 멈추기
                     break;
                   }
               }
           }
    
           // 정렬된 배열 출력
           for (int value : array) {
              System.out.print(value + " ");
           }
        }
     }
     ```

<br/>

**2. 삽입 정렬의 시간 복잡도 - $O(N^2)$** <br/>

  - 선택 정렬과 마찬가지로 반복이 2번 중첩되어 사용되었다.
  - 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다.
  - 최선의 경우 $O(N)$의 시간복잡도를 가진다.
  - 보통은 삽입 정렬이 비효율적이다. <br/> 그러나, 정렬이 거의 되어 있는 상황에서는 퀵 정렬 알고리즘보다 더 강력하다.

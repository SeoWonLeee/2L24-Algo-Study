# 🏷️ 그리디

- 탐욕법
- 단순 무식하게, 탐욕적으로 문제를 푸는 알고리즘
- 현재 상황에서 지금 당장 좋은 것만 선택 (나중 상황 고려 X)
- 특정 문제를 해결할 때, 단순히 현재 상황에서 가장 좋아보이는 것만을 선택해도 문제를 풀 수 있는지 파악
- 사전에 사용방법을 외우고 있지 않아도 풀 수 있을 가능성이 높은 문제 유형
<br/>

### **📌 Tip**

- 그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘 → “가장 큰 순서대로”, “가장 작은 순서대로” etc
- 정렬 알고리즘과 함께 적용될 때 시너지 효과 → 그리디 + 정렬 알고리즘 출제
- 유형을 바로 파악하기 어려운 문제는 먼저 그리디 알고리즘을 적용
<br/>(만약, 그리디 알고리즘으로 해결되지 어려운 경우, 다이나믹 프로그래밍 or 그래프 알고리즘 등으로 해결할 수 있는지 고민)
<br/>

### **🚪 예제 ; 거스름 돈**

거스름 돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다. 거슬러 줘야 할 돈이 1,260원일 때, 거슬러 줘야 할 동전의 최소 개수를 구하라. (단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.)

<br/>

**🔑 가장 큰 화폐 단위부터 거슬러 주는 것.** <br/>
먼저 500원으로 거슬러 줄 수 있을 만큼 거슬러 준다. 그 다음 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러 준다. 

<br/>

<예시코드>

```java
    public class Main {
      public static void main(String[] args) {
        int n = 1260;
        int cnt = 0;
        int[] coinTypes = {500, 100, 50, 10};
        
        for (int i = 0; i < 4; i++) {
          int coin = coinTypes[i];
          cnt += n / coin;
          n %= coin;
        }
        
        System.out.println(cnt);
      }
    }
```

<내가 생각한 코드>

```java
    public class ChangeMoney {
      public static void main(String[] args) {

        int n= 1260;
        int count = 0;
        int coins[] = {500, 100, 50, 10};

        for(int i=0; i<coins.length; i++) {
            count += n/coins[i];
            n %= coins[i];
        }

        System.out.println(count);
      }
    }
```

<br/>

### **💡 그리디 알고리즘의 정당성**

- 탐욕적으로 문제에 접근했을 때, 정확한 답을 찾을 수 있다는 보장이 있는 경우 매우 효과적이고 직관적
- 그리디 알고리즘을 이용해 문제 해결할 경우, 최소한의 아이디어를 떠올리고 해결 방법에 대한 정당성 검토 후 결과 도출
- 거스름 돈 문제의 그리디 알고리즘 적용 → 가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없음<br/>
ex) 800원을 거슬러 주는 경우,<br/>
&nbsp;&nbsp;&nbsp;&nbsp; ① 4개의 동전(500원+100원+100원+100원)으로 거슬러 줘야 되는 결과가 나오는데,<br/>
&nbsp;&nbsp;&nbsp;&nbsp; ② 2개의 동전(400원+400원)을 거슬러 주는 것이 최적의 해.
